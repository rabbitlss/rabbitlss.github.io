
1.两数之和
给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:
给定
nums = [2, 7, 11, 15], target = 9
因为
nums[0] + nums[1] = 2 + 7 = 9
所以返回[0, 1]

解法一：
将数组排序，之后设置两个高低指针，从两端遍历，若所指数之和小于target，则低指针加一，若大于则高指针减一，等于则返回。

![屏幕快照 2020-08-29 上午12.40.28](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.40.28.png)

解法二：
暴力求解，两层循环:

![屏幕快照 2020-08-29 上午12.40.59](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.40.59.png)

解法三：使用字典映射，键为数组元素，值为数组元素的下标：

![屏幕快照 2020-08-29 上午12.41.27](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.41.27.png)

1. 三数之和
   给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
   注意：答案中不可以包含重复的三元组。

示例：
给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为：
[
[-1, 0, 1],
[-1, -1, 2]
]

解法一：三数之和为0，则至少有一个数必然小于等于0，根据此性质，将数组排序，则第一个数应存在于小于等于0的范围，第二个数和第三个数在第一个数之后的范围里寻找，即化为了两数之和的问题，使用高低指针法解决即可：

​	![屏幕快照 2020-08-29 上午12.42.02](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.42.02.png)

1. 最接近的三数之和
   给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案
   示例：
   输入：nums = [-1,2,1,-4], target = 1
   输出：2
   解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

提示：
3 <= nums.length <= 10^3
-10^3 <= nums[i] <= 10^3
-10^4 <= target <= 10^4

解法一：
此题将三数之和为0改为三数之和最接近某数，令后两数之和等于target减去第一个数即可回到三数之和的套路，定义一个ans来记录最接近target的值，
然后依然使用高低指针法查找，每次产生的的三数之和都要判断看是否需要更新，注意判断更新的条件写法以及高低指针移动时跳过相同值：

![屏幕快照 2020-08-29 上午12.42.44](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.42.44.png)



四数之和
给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
注意：
答案中不可以包含重复的四元组。
示例：
给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。
满足要求的四元组集合为：
[
[-1, 0, 0, 1],
[-2, -1, 1, 2],
[-2, 0, 0, 2]
]
解法一：
此题需要多加一层循环，选定第一个数后，第二个数从第一个数的后一个数开始，就转化为了三数之和问题，注意每一层循环里最开始跳过重复值的细节

![屏幕快照 2020-08-29 上午12.43.14](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.43.14.png)

1. 字母异位词分组
   给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
   示例:
   输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]
   输出:
   [
   [“ate”,“eat”,“tea”],
   [“nat”,“tan”],
   [“bat”]
   ]
   说明：
   所有输入均为小写字母。
   不考虑答案输出的顺序。

方法一：排序法
使用collections.defaultdict来初始化一个字典，然后将每一个字符串都排序然后转化成元组，作为键写入字典，字典的值最开始是一些空列表，用来记录字符组成与键相同的字符串：

![屏幕快照 2020-08-29 上午12.43.42](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.43.42.png)

方法二：计数法
还是创建一个字典，键为一个记录字母出现次数的元组，值还是记录字符串的列表：

![屏幕快照 2020-08-29 上午12.44.00](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.44.00.png)

1. 直线上最多的点数
   给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。
   示例 1:
   输入: [[1,1],[2,2],[3,3]]
   输出: 3
   解释:
   ^
   |
   | o
   | o
   | o
   ±------------>
   0 1 2 3 4
   示例 2:
   输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
   输出: 4
   解释:
   ^
   |
   | o
   | o o
   | o
   | o o
   ±------------------>
   0 1 2 3 4 5 6

解法一：使用求最大公约数的方法求斜率，化简为int/int最简形式，这样不存在精度问题，创建一个字典，以化简后的斜率为键，统计经过一个点的所有直线中哪个直线上点最多，依次遍历所有点，即可找出直线上最多的点：

![屏幕快照 2020-08-29 上午12.44.38](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.44.38.png)

![屏幕快照 2020-08-29 上午12.44.54](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.44.54.png)

存在重复元素
给定一个整数数组和一个整数k，判断数组中是否存在两个不同的索引i和j，使得nums[i] = nums[j]，并且i和j的差的绝对值至多为k。
示例1:
输入: nums = [1, 2, 3, 1], k = 3
输出: true
示例2:
输入: nums = [1, 0, 1, 1], k = 1
输出: true
示例
3:输入: nums = [1, 2, 3, 1, 2, 3], k = 2
输出: false
解法一：暴力解法，用一个指针i遍历数组，检查在i+1到i+k+1的范围内所有值看是否与i相同：

![屏幕快照 2020-08-29 上午12.45.22](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.45.22.png)

解法二：建立一个字典，遍历nums中的元素，如果nums[i]在字典中并且下标与i的距离小于等于k，则返回true：

![屏幕快照 2020-08-29 上午12.45.41](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.45.41.png)


存在重复元素
在整数数组nums中，是否存在两个下标i和j，使得nums[i]和nums[j]的差的绝对值小于等于t ，且满足i和j的差的绝对值也小于等于ķ 。
如果存在则返回true，不存在返回false。
示例1:
输入: nums = [1, 2, 3, 1], k = 3, t = 0
输出: true
示例2:
输入: nums = [1, 0, 1, 1], k = 1, t = 2
输出: true
示例3:
输入: nums = [1, 5, 9, 1, 5, 9], k = 2, t = 3
输出: false

解法一：遍历I，在I后的k个数里寻找符合条件的数

![屏幕快照 2020-08-29 上午12.46.07](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.46.07.png)

方法二：

![屏幕快照 2020-08-29 上午12.46.33](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.46.33.png)

![屏幕快照 2020-08-29 上午12.46.51](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.46.51.png)

回旋镖的数量
给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。
找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。
示例:
输入:
[[0,0],[1,0],[2,0]]
输出:
2
解释:
两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]
解法一：每次固定一个点，使用哈希表存储其他点到这个点的距离，如果存在记录次数，回旋镖的数量应为次数*（次数-1）：

![屏幕快照 2020-08-29 上午12.47.11](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.47.11.png)

1. 四数相加 II
   给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。
   为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。
   例如:
   输入:
   A = [ 1, 2]
   B = [-2,-1]
   C = [-1, 2]
   D = [ 0, 2]
   输出:
   2
   解释:
   两个元组如下:
2. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
3. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

解法一：
初始化计数器 dic，dic 记录数组 A 和 B 元素的和，及其次数
遍历数组 C 和 D，累加满足四数相加和为 0 的个数：

![屏幕快照 2020-08-29 上午12.47.37](/Users/lishanshan/Desktop/屏幕快照 2020-08-29 上午12.47.37.png)



