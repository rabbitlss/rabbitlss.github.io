


动态规划常常适用于**有重叠子问题**和**最优子结构**性质的问题，动态规划方法**所耗时间往往远少于朴素解法**。

### 主要思想

若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。

动态规划法仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量，

一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。

### 动态规划模板步骤：

- 确定动态规划状态
- 写出状态转移方程（画出状态转移表）
- 考虑初始化条件
- 考虑输出状态
- 考虑对时间，空间复杂度的优化（Bonus）

## 例题详解

接下来，我们对每个步骤进行详细的讲解，并给出不同题目中考虑的不同方式，争取让大家吃透动态规划的套路。
我们以最经典的动态规划题目——[Leetcode 300.最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/) 为例子。

### 题目描述

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18] 输出: 4  解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。

### 解题思路

**第一步：确定动态规划状态**

- 是否存在状态转移?

- 什么样的状态比较好转移，找到对求解问题最方便的状态转移?

  想清楚到底是直接用需要求的，比如长度作为dp保存的变量还是用某个判断问题的状态比如是否是回文子串来作为方便求解的状态

  该题目可以直接用一个一维数组`dp`来存储转移状态，`dp[i]`可以定义为以`nums[i]`这个数结尾的最长递增子序列的长度。举个实际例子，比如在`nums[10,9,2,5,3,7,101,18]`中，`dp[0]`表示数字10的最长递增子序列长度，那就是本身，所以为1，对于`dp[5]`对应的数字7来说的最长递增子序列是`[2,5,7]`（或者`[2,3,7]`）所以`dp[5]=3`。

**第二步：写出一个好的状态转移方程**

- 使用**数学归纳法**思维，写出准确的状态方程

  比如还是用刚刚那个`nums`数组，我们**思考一下是如何得到`dp[5]=3`的**：既然是递增的子序列，我们只要找到`nums[5]` (也就是7)前面那些结尾比7小的子序列，然后把7接到最后，就可以形成一个新的递增的子序列，也就是这个新的子序列也就是在找到的前面那些数后面加上7，相当长度加1。当然可能会找到很多不同的子序列，比如刚刚在上面列举的，但是只需要找到长度最长的作为`dp[5]`的值就行。总结来说就是比较当前`dp[i]`的长度和`dp[i]`对应产生新的子序列长度，我们用`j`来表示所有比`i`小的组数中的索引，可以用如下代码公式表示

  ![屏幕快照 2020-08-24 上午12.07.48](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.07.48.png)

  

- **Tips:** 在实际问题中，如果不能很快得出这个递推公式，可以先尝试一步一步把前面几步写出来，如果还是不行很可能就是 dp 数组的定义不够恰当，需要回到第一步重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。

**第三步：考虑初始条件**

 这是决定整个程序能否跑通的重要步骤，当我们确定好状态转移方程，我们就需要考虑一下边界值，边界值考虑主要又分为三个地方：

- dp数组整体的初始值

- dp数组(二维)i=0和j=0的地方

- dp存放状态的长度，是整个数组的长度还是数组长度加一，这点需要特别注意。

  对于本问题，子序列最少也是自己，所以长度为1，这样我们就可以方便的把所有的`dp`初始化为1，再考虑长度问题，由于`dp[i]`代表的是`nums[i]`的最长子序列长度，所以并不需要加一。
  所以用代码表示就是​`dp=[1]*len(nums)​`

  **Tips：**还有一点需要注意，找到一个方便的状态转移会使问题变得非常简单。举个例子，对于[Leetcode120.三角形最小路径和](https://leetcode-cn.com/problems/triangle/)问题，大多数人刚开始想到的应该是自顶向下的定义状态转移的思路，也就是从最上面的数开始定义状态转移，但是这题优化的解法则是通过定义由下到上的状态转移方程会大大简化问题，同样的对于[Leetcode53.最大子序和](https://leetcode-cn.com/problems/maximum-subarray/solution/)也是采用从下往上遍历，保证每个子问题都是已经算好的。这个具体我们在题目中会讲到。

  这里额外总结几种Python常用的初始化方法：

  - 对于产生一个全为1，长度为n的数组：
  - ![屏幕快照 2020-08-24 上午12.08.16](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.08.16.png)

对于产生一个全为0，长度为m，宽度为n的二维矩阵：

![屏幕快照 2020-08-24 上午12.08.35](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.08.35.png)

**第四步：考虑输出状态**

主要有以下三种形式，对于具体问题，我们一定要想清楚到底dp数组里存储的是哪些值，最后我们需要的是数组中的哪些值：

- 返回dp数组中最后一个值作为输出，一般对应二维dp问题。

- 返回dp数组中最大的那个数字，一般对应记录最大值问题。

- 返回保存的最大值，一般是`Maxval=max(Maxval,dp[i])`这样的形式。

  **Tips：**这个公式必须是在满足递增的条件下，也就是`nums[i]>nums[j]`的时候才能成立，并不是`nums[i]`前面所有数字都满足这个条件的，理解好这个条件就很容易懂接下来在输出时候应该是`max(dp)`而不是`dp[-1]`，原因就是dp数组由于计算递增的子序列长度，所以dp数组里中间可能有值会是比最后遍历的数值大的情况，每次遍历`nums[j]`所对应的位置都是比`nums[i]`小的那个数。举个例子，比如`nums=[1,3,6,7,9,4,10,5,6]`,而最后`dp=[1,2,3,4,5,3,6,4,5]`。
  总结一下，最后的结果应该返回dp数组中值最大的数。

  最后加上考虑数组是否为空的判断条件，下面是该问题完整的代码：

  ![屏幕快照 2020-08-24 上午12.09.04](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.09.04.png)

- **第五步：考虑对时间，空间复杂度的优化（Bonus）**

  **切入点：**
  我们看到，之前方法遍历dp列表需要O(N)O(N)*O*(*N*)，计算每个`dp[i]`需要O(N)O(N)*O*(*N*)的时间，所以总复杂度是O(N2)O(N^2)*O*(*N*2)

  前面遍历dp列表的时间复杂度肯定无法降低了，但是我们看后面在每轮遍历`[0,i]`的`dp[i]`元素的时间复杂度可以考虑设计状态定义，使得整个dp为一个排序列表，这样我们自然想到了可以利用二分法来把时间复杂度降到了O(NlogN)O(NlogN)*O*(*N**l**o**g**N*)。这里由于篇幅原因，如果大家感兴趣的话详细的解题步骤可以看好心人写的[二分方法+动态规划详解](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/)

  **模板总结：**

  ![屏幕快照 2020-08-24 上午12.09.31](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.09.31.png)

- 对于子序列问题，很多也都是用这个模板来进行解题，比如[Leetcode53.最大子序和](https://leetcode-cn.com/problems/maximum-subarray/solution/)。此外，其他情况的子序列问题可能需要二维的dp数组来记录状态，比如：[Leetcode5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)（下面会讲到） 、 [Leetcode1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/) (当涉及到两个字符串/数组时)
  如果你觉得刚刚那题有点难的话，不如我们从简单一点的题目开始理解一下这类子序列问题。接下来所有题目我们都按照那五个步骤考虑

  ## 算法应用

  ### [Leetcode 674.最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

  #### 题目描述

  给定一个未经排序的整数数组，找到最长且连续的的递增序列。

  ![屏幕快照 2020-08-24 上午12.10.23](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.10.23.png)

- #### 解题思路

  这道题是不是一眼看过去和上题非常的像，没错了，这个题目最大的不同就是**连续**两个字，这样就让这个问题简单很多了，因为如果要求连续的话，那么就不需要和上题一样遍历两遍数组，只需要比较前后的值是不是符合递增的关系。

  - **第一步：确定动态规划状态**
    对于这个问题，我们的状态**dp[i]也是以nums[i]这个数结尾的最长递增子序列的长度**
  - **第二步：写出状态转移方程**
    这个问题，我们需要分两种情况考虑，第一种情况是如果遍历到的数`nums[i]`后面一个数不是比他大或者前一个数不是比他小，也就是所谓的不是连续的递增，那么这个数列最长连续递增序列就是他本身，也就是长度为1。
    第二种情况就是如果满足有递增序列，就意味着当前状态只和前一个状态有关，`dp[i]`只需要在前一个状态基础上加一就能得到当前最长连续递增序列的长度。总结起来，状态的转移方程可以写成
    `dp[i]=dp[i-1]+1`
  - **第三步：考虑初始化条件**
    和上面最长子序列相似，这个题目的初始化状态就是一个一维的全为1的数组。
  - **第四步：考虑输出状态**
    与上题相似，这个问题输出条件也是求dp数组中最大的数。
  - **第五步：考虑是否可以优化**
    这个题目只需要一次遍历就能求出连续的序列，所以在时间上已经没有可以优化的余地了，空间上来看的话也是一维数组，并没有优化余地。

  综上所述，可以很容易得到最后的代码：

  ![屏幕快照 2020-08-24 上午12.10.56](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.10.56.png)

- **总结: 通过这个题目和例题的比较，我们需要理清子序列和子数组（连续序列）的差别，前者明显比后者要复杂一点，因为前者是不连续的序列，后者是连续的序列，从复杂度来看也很清楚能看到即使穷举子序列也比穷举子数组要复杂很多。**

  承接上面的话题，我们接下来继续来看一个子序列问题，这次是另外一种涉及二维状态的题目。

  ### [Leetcode5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

  #### 题目描述

  给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

  ![屏幕快照 2020-08-24 上午12.11.25](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.11.25.png)

- **第一步：确定动态规划状态**
  与上面两题不同的是，这个题目必须用二维的dp数组来记录状态，主要原因就是子串有回文的限制。用两个指针来记录子串的位置可以很好的实现子串的回文要求，又因为最后结果需要返回的是子串，这里不同于之前题目的用dp保存长度，我们必须找到具体哪个部分符合回文子串的要求。这里插一句，其实也有求回文子串长度的题目[Leetcode516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/),如果有兴趣可以看一下。这里我们定义`dp[i][j]`表示子串s从i到j是否为回文子串。

- **第二步：写出状态转移方程**
  首先我们需要知道符合回文的条件：

  - 字符串首尾两个字符必须相等，否则肯定不是回文。

  - 当字符串首尾两个字符相等时：如果子串是回文，整体就是回文，这里就有了动态规划的思想，出现了子问题；相反，如果子串不是回文，那么整体肯定不是。
    对于字符串`s,s[i,j]`的子串是`s[i+1,j-1]`，如果子串只有本身或者空串，那肯定是回文子串了，所以我们讨论的状态转移方程不是对于`j-1-(i+1)+1<2`的情况(整理得`j-i<3`)，当`s[i]`和`s[j]`相等并且`j-i<3`时，我们可以直接得出`dp[i][j]`是True。

    综上所述，可以得到状态转移方程

    ![屏幕快照 2020-08-24 上午12.11.49](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.11.49.png)

    - **第三步：考虑初始化条件**
      我们需要建立一个二维的初始状态是False的来保存状态的数组来表示dp，又因为考虑只有一个字符的时候肯定是回文串，所以dp表格的对角线`dp[i][i]`肯定是True。

    - **第四步：考虑输出状态**
      这里dp表示的是从`i`到`j`是否是回文子串，这样一来就告诉我们子串的起始位置和结束位置，但是由于我们需要找到最长的子串，所以我们优化一下可以只记录起始位置和当前长度（当然你要是喜欢记录终止位置和当前长度也是没问题的）

      ![屏幕快照 2020-08-24 上午12.12.14](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.12.14.png)

      **第五步：考虑对时间，空间复杂度的优化**
      对于这个问题，时间和空间都可以进一步优化，对于空间方面的优化：这里采用一种叫中心扩散的方法来进行，而对于时间方面的优化，则是用了Manacher‘s Algorithm（马拉车算法）来进行优化。具体的实现可以参考[动态规划、Manacher 算法](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/)

      这里给出比较容易理解的经典方法的代码

      ![屏幕快照 2020-08-24 上午12.12.42](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.12.42.png)

      **总结：这个是一个二维dp的经典题目，需要注意的就是定义dp数组的状态是什么，这里不用长度作为dp值而用是否是回文子串这个状态来存储也是一个比较巧妙的方法，使得题目变得容易理解。**

      看了这么多套路相信你也对动态规划有点感觉了，这里再介绍一个求长度的子序列问题。

      ### [Leetcode516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

      #### 题目描述

      给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。

      ![屏幕快照 2020-08-24 上午12.13.23](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.13.23.png)

      #### 解题思路

      这个问题和上面的例题也非常相似，直接套用动态规划套路也可以很快解决出来：

      - **第一步：确定动态规划状态**
        这里求的是最长子串的长度，所以我们可以直接定义一个二维的`dp[i][j]`来表示字符串第`i`个字符到第`j`个字符的长度，子问题也就是每个子回文字符串的长度。

      - **第二步：写出状态转移方程**
        我们先来具体分析一下整个题目状态转移的规律。对于`d[i][j]`,我们根据上题的分析依然可以看出，
        当`s[i]`和`s[j]`相等时，`s[i+1...j-1]`这个字符串加上2就是最长回文子序列；
        当`s[i]`和`s[j]`不相等时，就说明可能只有其中一个出现在s[i,j]的最长回文子序列中，我们只需要取`s[i-1,j-1]`加上`s[i]`或者`s[j]`的数值中较大的；
        综上所述，状态转移方程也就可以写成：

      - ![屏幕快照 2020-08-24 上午12.13.47](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.13.47.png)

      - 但是问题来了，具体我们应该怎么求每个状态的值呢？这里介绍一种利用状态转移表法写出状态转移方程，我们通过把`dp[i][j]`的状态转移直接画成一张二维表格，我们所要做的也就是往这张表中填充所有的状态，进而得到我们想要的结果。如下图：

      - ![屏幕快照 2020-08-24 上午12.14.09](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.14.09.png)

      - 我们用字符串为"**cbbd**"作为输入来举例子，每次遍历就是求出右上角那些红色的值，通过上面的图我们会发现，按照一般的习惯都会先计算第一行的数值，但是当我们计算`dp[0,2]`的时候，我们会需要`dp[1,2]`，按照这个逻辑，我们就可以很容易发现遍历从下往上遍历会很方便计算。

        - **第三步：考虑初始化条件**
          很明显看出来的当只有一个字符的时候，最长回文子序列就是1，所以可以得到`dp[i][j]=1(i=j)`
          接下来我们来看看
          当`i>j`时，不符合题目要求，不存在子序列，所以直接初始化为0。
          当`i<j`时，每次计算表中对应的值就会根据前一个状态的值来计算。

        - **第四步：考虑输出状态**

          我们想要求最长子序列的时候，我们可以直接看出来`dp[0][-1]`是最大的值，直接返回这个值就是最后的答案。

        - **第五步：考虑对时间，空间复杂度的优化**
          对于这个题目，同样可以考虑空间复杂度的优化，因为我们在计算`dp[i][j]`的时候，只用到左边和下边。如果改为用一维数组存储，那么左边和下边的信息也需要存在数组里，所以我们可以考虑在每次变化前用临时变量`tmp`记录会发生变化的左下边信息。所以状态转移方程就变成了：

        - ![屏幕快照 2020-08-24 上午12.14.48](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.14.48.png)

        - 这里给出基本版的实现代码，如果需要优化后的可以看[空间压缩优化解法](https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/dong-tai-gui-hua-jiang-wei-kong-jian-ya-suo-te-shu/)

        - ![屏幕快照 2020-08-24 上午12.15.09](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.15.09.png)

        - **总结：对于二维的数组的动态规划，采用了画状态转移表的方法来得到输出的状态，这种方法更加直观能看出状态转移的具体过程，同时也不容易出错。当然具体选择哪种方法则需要根据具体题目来确定，如果状态转移方程比较复杂的利用这种方法就能简化很多。**

          **模板总结：**

          ![屏幕快照 2020-08-24 上午12.15.30](/Users/lishanshan/Desktop/屏幕快照 2020-08-24 上午12.15.30.png)

          当然，动态规划除了解决子序列问题，也可以用来解决其他实际的问题，比如之前提到过的各种AI的经典算法，接下来我们来看一道动态规划的高频面试题，也是实际开发中很常用的。
